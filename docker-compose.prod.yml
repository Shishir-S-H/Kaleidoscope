# Unified Production Docker Compose - Kaleidoscope AI Services
#
# This file orchestrates all services with proper startup order:
# 1. Infrastructure: redis â†’ elasticsearch (with healthchecks)
# 2. Backend: app (depends on redis/elasticsearch)
# 3. AI Services: All 7 services (depend on redis)
# 4. Reverse Proxy: nginx (depends on app)
#
# Image Strategy:
# - Backend: Pulls from ajayprabhu2004/kaleidoscope:backend-latest
# - AI Services: Pull from shishir01/kaleidoscope-{service}:latest
# - Infrastructure: Official images (redis, elasticsearch, nginx, certbot)

services:
  # ============================================
  # Infrastructure Layer (Start First)
  # ============================================

  redis:
    image: redis:alpine
    container_name: redis
    restart: always
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD} --protected-mode yes
    # Secure: Port exposed only to localhost for SSH Tunnel
    ports:
      - "127.0.0.1:6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - kaleidoscope-network
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 256M

  elasticsearch:
    image: elasticsearch:8.10.2
    container_name: elasticsearch
    restart: always
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=true
      - xpack.security.http.ssl.enabled=false
      - ELASTIC_PASSWORD=${ELASTICSEARCH_PASSWORD}
      - "ES_JAVA_OPTS=-Xms1g -Xmx1g"
    # Secure: Port exposed only to localhost for SSH Tunnel
    ports:
      - "127.0.0.1:9200:9200"
    volumes:
      - es-data:/usr/share/elasticsearch/data
    networks:
      - kaleidoscope-network
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -f -u elastic:${ELASTICSEARCH_PASSWORD} http://localhost:9200/_cluster/health || exit 1",
        ]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    deploy:
      resources:
        limits:
          cpus: "1.0"
          memory: 2G

  # ============================================
  # Backend Layer (Depends on Infrastructure)
  # ============================================

  app:
    # Backend image from ajayprabhu2004 registry
    image: ${DOCKER_REGISTRY:-ajayprabhu2004}/kaleidoscope:backend-${APP_VERSION:-latest}
    container_name: ${APP_CONTAINER_NAME:-kaleidoscope-app}
    restart: unless-stopped
    depends_on:
      redis:
        condition: service_healthy
      elasticsearch:
        condition: service_healthy
    env_file:
      - .env
    environment:
      # Production overrides - point to internal Docker service names
      - SPRING_ELASTICSEARCH_URIS=http://elasticsearch:9200/
      - SPRING_ELASTICSEARCH_USERNAME=elastic
      - SPRING_ELASTICSEARCH_PASSWORD=${ELASTICSEARCH_PASSWORD}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      # PostgreSQL (Neon DB) - explicitly set to ensure it's loaded
      - SPRING_DATASOURCE_URL=${SPRING_DATASOURCE_URL}
      - SPRING_DATASOURCE_USERNAME=${DB_USERNAME}
      - SPRING_DATASOURCE_PASSWORD=${DB_PASSWORD}
      # Spring Boot configs - from .env file
      - SPRING_PROFILES_ACTIVE=${SPRING_PROFILES_ACTIVE:-production}
      - CONTEXT_PATH=${CONTEXT_PATH:-/kaleidoscope}
      - APP_BASE_URL=${APP_BASE_URL}
      # Other configs from .env
      - CLOUDINARY_CLOUD_NAME=${CLOUDINARY_CLOUD_NAME}
      - CLOUDINARY_API_KEY=${CLOUDINARY_API_KEY}
      - CLOUDINARY_API_SECRET=${CLOUDINARY_API_SECRET}
      - JWT_SECRET=${JWT_SECRET}
      - MAIL_HOST=${MAIL_HOST}
      - MAIL_PORT=${MAIL_PORT}
      - MAIL_USERNAME=${MAIL_USERNAME}
      - MAIL_PASSWORD=${MAIL_PASSWORD}
      - ALLOWED_ORIGINS=${ALLOWED_ORIGINS}
    # Secure: Public port removed. Nginx is the entrypoint.
    networks:
      - kaleidoscope-network
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      resources:
        limits:
          cpus: "1.0"
          memory: 1G

  # ============================================
  # AI Services Layer (Depend on Redis)
  # ============================================

  content_moderation:
    # Pull from Docker Hub (shishir01 registry)
    image: ${DOCKER_USERNAME:-shishir01}/kaleidoscope-content_moderation:latest
    container_name: content_moderation
    restart: always
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - HF_API_URL=${HF_API_URL_CONTENT_MODERATION}
      - HF_API_TOKEN=${HF_API_TOKEN}
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - kaleidoscope-network
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 512M

  image_tagger:
    image: ${DOCKER_USERNAME:-shishir01}/kaleidoscope-image_tagger:latest
    container_name: image_tagger
    restart: always
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - HF_API_URL=${HF_API_URL_IMAGE_TAGGER}
      - HF_API_TOKEN=${HF_API_TOKEN}
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - kaleidoscope-network
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 512M

  scene_recognition:
    image: ${DOCKER_USERNAME:-shishir01}/kaleidoscope-scene_recognition:latest
    container_name: scene_recognition
    restart: always
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - HF_API_URL=${HF_API_URL_SCENE_RECOGNITION}
      - HF_API_TOKEN=${HF_API_TOKEN}
      - SCENE_LABELS=${SCENE_LABELS:-beach,mountains,urban,office,restaurant,forest,desert,lake,park,indoor,outdoor,rural,coastal,mountainous,tropical,arctic}
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - kaleidoscope-network
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 512M

  image_captioning:
    image: ${DOCKER_USERNAME:-shishir01}/kaleidoscope-image_captioning:latest
    container_name: image_captioning
    restart: always
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - HF_API_URL=${HF_API_URL_IMAGE_CAPTIONING}
      - HF_API_TOKEN=${HF_API_TOKEN}
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - kaleidoscope-network
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 512M

  face_recognition:
    image: ${DOCKER_USERNAME:-shishir01}/kaleidoscope-face_recognition:latest
    container_name: face_recognition
    restart: always
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - HF_API_URL=${HF_API_URL_FACE_RECOGNITION}
      - HF_API_TOKEN=${HF_API_TOKEN}
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - kaleidoscope-network
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 512M

  post_aggregator:
    image: ${DOCKER_USERNAME:-shishir01}/kaleidoscope-post_aggregator:latest
    container_name: post_aggregator
    restart: always
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - kaleidoscope-network
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 512M

  es_sync:
    image: ${DOCKER_USERNAME:-shishir01}/kaleidoscope-es_sync:latest
    container_name: es_sync
    restart: always
    env_file:
      - .env
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - ES_HOST=http://elastic:${ELASTICSEARCH_PASSWORD}@elasticsearch:9200
      # PostgreSQL connection (Neon DB) - from .env file
      - SPRING_DATASOURCE_URL=${SPRING_DATASOURCE_URL}
      - DB_USERNAME=${DB_USERNAME}
      - DB_PASSWORD=${DB_PASSWORD}
    depends_on:
      redis:
        condition: service_healthy
      elasticsearch:
        condition: service_healthy
    networks:
      - kaleidoscope-network
    deploy:
      resources:
        limits:
          cpus: "0.5"
          memory: 512M

  # ============================================
  # Reverse Proxy Layer (Depends on App)
  # ============================================

  nginx:
    image: nginx:alpine
    container_name: nginx-proxy
    restart: unless-stopped
    ports:
      - "80:80" # Public port for HTTP and SSL challenge
      - "443:443" # Public port for HTTPS
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - certbot-etc:/etc/letsencrypt
      - certbot-www:/var/www/certbot
    networks:
      - kaleidoscope-network
    depends_on:
      app:
        condition: service_started

  certbot:
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - certbot-www:/var/www/certbot

# --- END OF 'services:' BLOCK ---

networks:
  kaleidoscope-network:
    driver: bridge

# --- NEW VOLUMES FOR SSL ---
volumes:
  redis-data:
  es-data:
  certbot-etc: # Volume for Certbot certificates
  certbot-www: # Volume for Certbot challenge files
